from bestDays import *
from planner import geraDocx

import numpy as np
import matplotlib.pyplot as plt

class GenerateCalendar:

    def __init__(self, number_of_days, showNumberPages = True):
        self.number_of_days = number_of_days
        self.pages, self.titles = chaptersWithPages("cap.txt")
        self.showNumberPages = showNumberPages
    
    def search_dynamic_parameters(self, number_of_cycles):
        parameters, best_fit, self.individuals, self.inf_graph = the_best(self.number_of_days, number_of_cycles)

        print("I was chosen with ", str(best_fit)+" for fitness")
        print("Parameters:", parameters)

        self.original_goals = self.__individuals2caps()
        self.goals = self.original_goals

    def search_user_parameters(self,
                               number_generations,
                               number_individuals, 
                               number_participants_tournament,
                               mutation_probability,
                               elitism
                               ):
        """
        :param number_generations:int - number of generations
        :param number_individuals:int - number of individuals
        :param number_participants_tournament:int - number of participants in the tournament
        :param mutation_probability:float - mutation probability (between 0 and 1, inclusive)
        :param elitism:bool - whether there will be elitism
        :return:list - best individual found
        """

        self.individuals, self.inf_graph = run_ga(number_generations,
                               number_individuals, 
                               number_participants_tournament,
                               mutation_probability,
                               elitism, 
                               self.number_of_days, 
                               True)

        best_fit = evaluate(self.individuals)
        print("Fitness", best_fit)

        self.original_goals = self.__individuals2caps()
        self.goals = self.original_goals

    def genetic_algorithm_graph(self):
        max_fit = self.inf_graph[0]
        min_fit = self.inf_graph[1]
        avarage_fit = self.inf_graph[2]
        n_range = self.inf_graph[3]
        x = np.arange(0, n_range)

        plt.figure(figsize=(6, 4))
        plt.plot(x, min_fit, color='green', label='Menor') 
        plt.plot(x, max_fit, color='red', label='Maior')
        plt.plot(x, avarage_fit, color='blue', label='Media')

        plt.xlabel("Gerações",fontsize=13)
        plt.ylabel("Fitness",fontsize=13)

        plt.legend()
        plt.show()
        plt.close()

    def print_caps_per_day(self):
        zipped = zip(self.individuals[0], self.individuals[1])

        for day_pages in list(zipped):
            if(day_pages[1] == NO_PAGE):
                break
                
            if(not isinstance(day_pages[0], list)):
                print(self.titles[day_pages[0]], "|", day_pages[1])
            else:
                for cap in day_pages[0]:
                    print(self.titles[cap], end=' | ')
                print(day_pages[1])
                print("")

    def __individuals2caps(self):
        CAP = 0
        PAGES = 1

        zipped = zip(self.individuals[CAP], self.individuals[PAGES])
        goals_list = []

        # Generate the list with the division generated by the genetic algorithm
        for day_pages in list(zipped):
            #Se não há capítulo no dia, então já adicionou todos
            if(day_pages[1] == NO_PAGE):
                break
            
            # If there is no chapter on the day, then you have already added all
            if(not isinstance(day_pages[0], list)):
                final_title = [self.titles[day_pages[CAP]]]
            else:
                final_title = []
                for cap in day_pages[0]:
                    final_title += [self.titles[cap]]
            
            #Add the target to the list
            goals_list.append([final_title, day_pages[PAGES]])
            
        return goals_list

    def split_goals(self, max_caps_day, split_symbol = "↑"):
        TITLE = 0
        CAP = 1

        #Days without chapters
        extra_days = self.number_of_days - (len(self.original_goals))

        #List to calculate number of pages
        chapters_calculated = copy.deepcopy(self.original_goals)
        splited_goals = copy.deepcopy(self.original_goals)

        while(extra_days > 0):
            # List with the number of chapters
            caps = [cap[CAP] for cap in chapters_calculated] 
            
            # Index of the chapter with the most pages
            max_idx = caps.index(max(caps))

            extra_days -=1
            
            # Chapter and division information
            if(chapters_calculated[max_idx][CAP] > max_caps_day):
                titulo = chapters_calculated[max_idx][TITLE]
                chapters_calculated[max_idx][CAP] = chapters_calculated[max_idx][CAP]/2
            
                # Insert the division
                chapters_calculated.insert(max_idx+1, [titulo, chapters_calculated[max_idx][CAP]])
                splited_goals.insert(max_idx+1, [titulo, split_symbol])

        self.goals = splited_goals

    def restore_original_goals(self):
        self.goals = self.original_goals

    def list_of_goals(self):
        TITLE = 0
        CAP = 1

        if self.showNumberPages:
            string_list_capitulos = [[" | ".join(capitulo[TITLE]), str(capitulo[CAP])] for capitulo in self.goals]
            capitulos_divididos_string = [" | ".join(capitulo) + "\n" for capitulo in string_list_capitulos]
        else:
            capitulos_divididos_string = [" | ".join(capitulo[TITLE]) + "\n" for capitulo in self.goals]

        return capitulos_divididos_string

    def create_docx(self, file_name, title, author, weekendMessage, caps_file_name, skipWeekend, start_day, start_month, start_year):
        with open('readme.txt', 'w', encoding='utf-8') as f:
            f.writelines(self.list_of_goals())
        f.close()

        geraDocx(file_name, title, author, weekendMessage, caps_file_name, skipWeekend, start_day, start_month, start_year)

